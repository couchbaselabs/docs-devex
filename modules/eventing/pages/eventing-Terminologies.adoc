= Eventing Terminology
:description: The following terminology is used by the Eventing Service.
:page-toclevels: 2
[abstract]
{description}








Typically you should set Function Scope to the bucket.scope that holds the collection that is the source of your mutations to your Eventing Function.  This best practice ensures that you _*do not*_  inadvertently cause an Eventing Function to undeploy by removing a *Function Scope* pointing to a resource that is not required for the function to run.



[#function-scope]
=== Function Scope
You can use the Function scope, or `bucket.scope`, to identify Functions that belong to the same group.

To set the `bucket.scope` to `+`.`+`, you must have the `Eventing Full Admin` or the `Full Admin` role.
All other users must use a scope that references an existing resource of their `bucket.scope`.



[#eventing-keyspaces]
=== Eventing Keyspaces

A keyspace is a path to a collection in the format `bucket-name.scope-name.collection-name`.

For backward compatibility, you can also use the format `bucket-name._default._default`.
This is the format of a bucket from Couchbase Server version 6.6 that is upgraded to version 7.0.

The following are the two keyspaces used by Eventing Functions:

* <<listen-to-location,Listen to Location>>, which represents the Eventing source
* <<eventing-storage,Eventing Storage>>, which represents the Eventing metadata

[#listen-to-location]
==== Listen to Location

Eventing Functions use a collection as the source for their data mutations.
This collection is called the Eventing source, and can be made up of Couchbase or Ephemeral keyspace types.
Memcached keyspace types are not supported.

When you create an Eventing Function, you must specify a source collection.
The `OnUpdate` and `OnDelete` handlers are the entry points for this collection; they receive events and receive and track data mutations.
When you delete a source collection, all deployed and paused Functions associated with the collection are undeployed.

While a Function is processing its JavaScript code, the Function's documents can be mutated in different collections.
You can set keyspaces as destination collections, which are then bound to the Function through bucket aliases.

The Function's JavaScript code triggers data mutations on documents through Basic Keyspace Accessors or Advanced Keyspace Accessors in the Data Service.
If the code directly modifies documents in the source collection, the Eventing Service suppresses the mutation back to the Function performing the mutation.

The Function's JavaScript code can also trigger mutations on documents through inline {sqlpp} statements in the Query Service or `N1QL()` function calls.

NOTE: When you implement multiple Functions, you can create infinite recursions.
The Eventing Service prevents the deployment of Functions that might result in recursion loops.
For more information abotu cyclic generation of data changes, see xref:troubleshooting-best-practices.adoc#cyclicredun[Bucket Allocation Considerations].

To get the `Listen To` keyspace to listen to multiple collections, you can use a `{asterisk}` wildcard for the scope or collection.
If the bucket binding used by the JavaScript code also has a `{asterisk}` wildcard for its scope or collection, you must use Advanced Keyspace Accessors to read or write the Data Service. 
For more information about Advanced Keyspace Accessors, see xref:eventing-advanced-keyspace-accessors.adoc#multiple-collection-functions[Eventing Functions that Listen to Multiple Collections].

TIP: You can have multiple Functions listening to the same collection while running different code.
To use less resources, though, you can use only one Function and code an if-then-else or switch statement in your handler's JavaScript.

[#eventing-storage]
=== Eventing Storage
The Eventing Storage is the Eventing Function's metadata bucket. 
The metadata bucket stores artifacts, or configuration documents, that contain information about DCP streams, worker allocations, Timer information and state, and internal checkpoints. 

When you create an Eventing Function, you must make sure that a separate collection has been designated as an Eventing metadata and reserved for the Eventing Service's internal use.
You can use a common Eventing metadata collection across multiple Eventing Functions for the same tenant.

The Eventing Storage keyspace must be in a Couchbase-type bucket.
If this keyspace is not persistent, the Data Service evicts Timer and checkpoint documents when it hits quota, and loses track of Timers and mutations that have been processed.

NOTE: Do not delete the Eventing metadata collection.
Make sure that your Function's JavaScript code does not perform a write or delete operation on the Eventing metadata collection.
If you delete the metadata collection, all deployed Eventing Functions are undeployed and all associated indexes and constructs are dropped.

[#function-settings]
=== Eventing Function Settings
[cols="1,2",options="header"]
|===
|Function setting 
|Description

|Function Name
a|A unique name for your Eventing Function.

The Function name must:

* Start with an uppercase character (A-Z), lowercase character (a-z), or number (0-9)
* Contain only uppercase characters (A-Z), lowercase characters (a-z), numbers (0-9), underscores (_), and hyphens (-)

|Description
|An optional description that describes the purpose of your Eventing Function.

|Deployment Feed Boundary
|The Feed Boundary determines if the Eventing Function's activities need to include documents that already exist.

When you set the Feed Boundary to `Everything`, the Function deploys all mutations available in your database.
When you set the Feed Boundary to `From Now`, the Function only processes instances of data mutation that happen after the Function's deployment.

The Feed Boundary also works as a checkpoint for paused Functions.
When you resume a paused Function, the Feed Boundary makes sure that no mutations are lost or processed again.

You can only modify the Feed Boundary when you create a Function or when a Function is undeployed or paused.

|System Log Level
|Determines the granularity of messages logged across the Eventing Function.

Can be one of `Info` (the default), `Error`, `Debug`, `Warning`, or `Trace`.

|Application Log Location
|The directory path to the log file for the Eventing Function.
The format is `<function_name>.log`.

The Function uses `log()` statements to write to this file.
When you select the *Log* value on the UI, all log files are combined across Eventing nodes and displayed.

The log value is read-only and cannot be changed.

|{sqlpp} Consistency
|The default consistency level of {sqlpp} statements in the Eventing Function.
You can set the consistency level by statement.

Can be one of `None` (the default) or `Request`.

|Workers
|The number of worker threads per node to be allocated to the Eventing Function to process events. 
Allows the Function to scale up.

The minimum number of workers is `1` (the default) and the maximum is `64`.

|Language Compatibility
|The language version of the Eventing Function for backward compatibility.

If the semantics of a language construct change during a release, the Language Compatibility setting makes sure that an older Eventing Function continues to produce the runtime behavior from when the Function was initially created.
The older Function only stops this behavior when the behavior is deprecated and removed.

Couchbase versions 6.0.0, 6.5.0, and 6.6.2 are the only versions that are currently defined.
New Functions default to the highest compatibility version available of 6.6.2.

In version 6.5.0, trying to access a non-existing item from a keyspace returns an undefined value.
In version 6.0.0, it throws an exception.

Only a Function with a language compability setting of version 6.6.2 passes binary documents to Eventing Function handlers.
Versions 6.0.0 and 6.5.0 filter all binary documents out of the DCP mutation stream.

|Script Timeout
|The number of seconds to elapse before the script times out and is terminated.

The entry points into the handler processing for each mutation must run from start to finish before the specified timeout duration.

The default number of seconds is `60`.

|Time Context Max Size
|The size limit of the context for any Timer created by the Eventing Function.

A context can be any JSON document. 
Timers can store and access a context, which is then used to store the state of when a Timer is created and to retrieve the state of when a Timer is fired.

The default is `1024`.

|===


== Operations

Operations exposed through the UI, couchbase-cli, and REST APIs.

=== Deploy

The deploy operation activates an Eventing Function in a cluster.
It performs validations and allows only valid Eventing Functions to be deployed.

Deploying an Eventing Function:

* Creates necessary metadata
* Spawns worker processes
* Calculates initial partitions
* Initiates check-pointing of DCP streams to process
* Allows the Function to receive and process mutations and Timer callbacks

You cannot edit the source code of a deployed Eventing Function.

During deployment, you must choose one of the following *Deployment Feed Boundary* settings:

* *Everything*, which provides the Eventing Function with a deduplicated history of all documents, ending with the current value of each document. This means the Function sees every document in the keyspace at least once.
* *From now*, which provides the Eventing Function with mutations starting at deployment. This means the Function only sees documents that have mutated after the Function's deployment.

=== Undeploy

The undeploy operation causes the Eventing Function to stop processing events of all types.
It also shuts down the worker processes associated with the Function.

Undeploying an Eventing Function:

* Deletes all Timers and context documents created by the Function
* Releases any runtime resources acquired by the Function

You can edit the code and change the settings of an undeployed Eventing Function.
When you create a new Eventing Function, the Function's state is undeployed.

=== Pause

The pause operation causes the Eventing Function to pause all mutations and Timer callbacks.
It also performs a checkpoint to be used for resuming the Function.

You can edit the code and change the settings of a paused Eventing Function.
You can also resume or undeploy a paused Function.

=== Resume

The resume operation continues processing mutations and Timer callbacks of an Eventing Function that was previously paused.

The resume operation is similar to the deploy operation, but it uses a progress checkpoint to restart the Function. This means no mutations are lost or processed again.

When you resume a Function, the backlog of mutations that occurred when the Function was in a paused state is processed. 
The backlog of Timers also fires, even if the time of the Timers has already passed.

Depending on the system capacity and on how long the Function was paused, clearing the backlog can take some time. 
After the backlog is cleared, the Function goes on to process current mutations and Timers.

=== Delete

The delete operation deletes the following in the Eventing Function:

* The source code implementing the Function
* All Timers and Timer contexts
* All processing checkpoints
* Application logs
* Any other artifacts in the metadata provider

You can only delete an undeployed Eventing Function.

=== Debug

The debug operation traps and sends the next event instance received by the Eventing Function to a separate v8 worker with debugging enabled. 
Debug is a special flag that can be attach to a Function.

The debug operation pauses the trapped event, opens a TCP port, and generates a Chrome Developer Tools URL with a session cookie that can be used to control the debug worker.

With the exception of the trapped event instance, all other Eventing Function events continue processing.
When the trapped event finishes debugging, the debug operation traps another event instance.
This continues until you stop the operation.


== See Also

* xref:eventing-advanced-keyspace-accessors.adoc[Advanced Keyspace Accessors]
* xref:eventing-language-constructs.adoc#basic_bucket_accessors[Basic Keyspace Accessors]