= Language Constructs
:description: Language constructs are the fundamental units of a language.
:page-toclevels: 2

[abstract]
{description}

This page describes which JavaScript constructs Eventing Functions do and do not support.

You can use JavaScript to write custom functions.



||||||| <<<< NOTE TO SELF: remove "removed" and "added"?? Because I think these were removed/added for 7.0 release a while ago. So right now they're just things we do and don't support, not "removed/added" things. >>>>>























[abstract]
{description}
This topic discusses the JavaScript constructs that have been removed and new constructs that have been added in order to support the requirements of Couchbase Functions.

Using JavaScript, you can write your custom Functions.
Couchbase Functions inherit support for most ECMAScript constructs by using Google v8 as the execution container.
However, to support the ability to shard and scale Function-execution automatically, some capabilities have been removed.
Additionally, to optimize language-utilization of the server environment, some new constructs have been added.










[#supported-lang-features]
== Supported  Language Features

The following features are supported by Eventing Functions:

* <<basic_bucket_accessors,Basic Keyspace Accessors>>
* <<advanced_bucket_accessors,Advanced Keyspace Accessors>>
* <<logging,Logging>>
* <<n1ql_statements,{sqlpp} Statements>>

[#basic_bucket_accessors]
=== Basic Keyspace Accessors

Buckets that are bound to an Eventing Function appear as a global JavaScript map.
Map operations like GET, SET, and DELETE are exposed to the GET, SET, and DELETE Data Service provider operations.

If the bucket binding has a wildcard `*` for its scope or collection, you cannot use a Basic Keyspace Accessor to access the Data Service. Instead, you must use an <<advanced_bucket_accessors,Advanced Keyspace Accessor>>.

[cols="30,60",options="header"]

|===
|Operation
|Description

|GET
|`operator[]` is applied on a bucket binding and used as a value expression.

Fetches the object from the KV bucket that the variable is bound to.
Returns the parsed JSON value as a JavaScript object.

Fetching a non-existent object from a bucket returns an undefined value.
This operation throws an exception if the underlying bucket GET operation fails with an unexpected error.

|SET
|`operator[]` appears to the left of the `=` assignment statement.

Sets the provided JavaScript value into the KV bucket that the variable is bound to.
Replaces any existing value with the specified key.

This operation throws an exception if the underlying bucket SET operation fails with an unexpected error.

|DELETE
|`operator[]` appears afer the JavaScript delete keyword.

Deletes the provided key from the KV bucket that the variable is bound to.
Returns a no-op if the object does not exist.

This operation throws an exception if the underlying bucket DELETE operation fails with an unexpected error.

|===

[source,javascript]
----
function OnUpdate(doc, meta) {
  // Assuming 'dest' is a bucket alias or binding to a keyspace
  var val = dest[meta.id];         // this is a bucket GET operation
  dest[meta.id] = {"status":3};    // this is a bucket SET operation
  delete dest[meta.id];            // this is a bucket DEL operation
}
----

[#advanced_bucket_accessors]
=== Advanced Keyspace Accessors

Advanced Keyspace Accessors expose a larger set of options and operators than <<basic_bucket_accessors,Basic Keyspace Accessors>>.
They have non-trivial argument sets and return values.

See xref:eventing-advanced-keyspace-accessors.adoc[Advanced Keyspace Accessors] for more details.

[#logging]
=== Logging

The `log()` function allows Eventing Functions to log user-defined messages.
`log()` statements are logged in each Eventing Function's log file.

`log()` does not throw exceptions.

[source,javascript]
----
function OnUpdate(doc, meta) {
  log("Now processing: " + meta.id);
}
----

The Eventing Service also creates a system log file named `eventing.log`.
This file exists in all Eventing Functions and captures management and lifecycle information.
The end-user cannot write to this file.

See xref:eventing-debugging-and-diagnosability.adoc#logging-functions[Logging Functions] for more information.

[#n1ql_statements]
=== {sqlpp} Statements

You can use top-level {sqlpp} keywords like SELECT, UPDATE, INSERT, and DELETE as inline words in Eventing Functions.
These operations are accessible through the returned iterable handle.

{sqlpp} Query results, through the SELECT operation, are streamed in batches to the iterable handle as the iteration progresses through the result set.

NOTE: To avoid recursion, an Eventing Function can listen for mutations in a bucket. 
{sqlpp} DML statement canot manipulate documents in that same bucket.
To work around this, you can use the exposed data service KV map in your Eventing Function.

The following Function has a feed boundary of "Everything", which means the same {sqlpp} statement is executed 7,303 times.
To execute only one query, you can configure your feed boundary to be "From now" and to mutate only one document in the keyspace `beer-sample`.`_default`.`_default`.

You can also make sure you have an optimal index, which improves query performance by 24 times.

[source,javascript]
----
function OnUpdate(doc, meta) {
    var strong = 70;
    var results =
        SELECT *                               /* SQL++ queries are embedded directly */
        FROM `beer-sample`._default._default   /* Token escaping is standard SQL++ style */
        WHERE abv > $strong;                   // Local variable reference using $ syntax
    for (var beer of results) {                // Stream results using 'for' iterator
        log(beer);
        break;
    }
    results.close();                           // End the query and free resources held
}
----

The embedded {sqlpp} call starts the query and returns a JavaScript iterable object that represents the result set of the query. You can iterate the returned handle using standard JavaScript mechanisms like `for...of` loops.

The iterator is an input iterator, meaning the elements are read-only. 
The variables created inside the iterator are local to it.
You cannot use the keyword `this` in the body of the iterator.

You must close wach result set with the `close()` method, which stops the underlying {sqlpp} query and releases associated resources.
In some cases like nested {sqlpp} lookups, failing to explicitly call `close()` can use too many {sqlpp} resources and lead to poor performance.

=== Valid and Invalid Statements

{sqlpp} is not syntactically part of the JavaScript language. 
Eventing transpiles the Eventing Function code to identify {sqlpp} statements and convert them to a standard JavaScript function call. 
This call then returns an iterable object with a `close()` method.

To use a JavaScript variable in a query statement, you must use `$<variable>`.
This parameter is substituted in the query by the corresponding JavaScript variable's runtime value.

You cannot use the `meta.id` expression in the query statement. 
Instead, you can use `var id = meta.id` in a {sqlpp} query.

The following is a valid statement:
[source, sqlpp]
----
var id = meta.id;
DELETE FROM mybucket.myscope.transactions WHERE username = $id;
----

The following is an invalid statement:
[source, sqlpp]
----
DELETE FROM mybucket.myscope.transactions WHERE username = $meta.id;
----

==== Escape Identfiers

Escaped identifiers are surrounded by back ticks and support all identifiers in JSON.
When you use a {sqlpp} query inside an Eventing Function, you must also use an escaped identifier for keyspaces with special characters.

If the bucket name is `beer-sample` and the scope and collection are both `_default`, you only need to escape the bucket in the {sqlpp} query:
[source, sqlpp]
----
SELECT * FROM `beer-sample`._default._default WHERE type ...
----

If the bucket name is `beersample`, you do not need to escape the keyspace of the {sqlpp} query:
[source, sqlpp]
----
SELECT * FROM beersample._default._default WHERE type ...
----

==== End of Line Comments

In multiline {sqlpp} statements, you cannot use single line `// end of line comments` before the semicolon at the end of the statement. 
This causes syntax errors in the transformation and compilation of the {sqlpp} statement.

To include comments in multiline statements, use `/* this format */`.





















[#build-in-functions]
== Built-in Functions

The following built in functions have been added:

* <<n1ql_call,The N1QL() function call>>
* <<crc64_call,The crc64() function call>>
* <<createtimer_call,The createTimer() function call>>
* <<canceltimer_call,The cancelTimer() function call>>
* <<curl_call,The curl() function call>>

[#n1ql_call]
=== The N1QL() Function Call

The _N1QL()_ function call  is documented below for reference purposes but should not used directly as doing so would bypass the various semantic and syntactic checks of the transpiler (notably: recursive mutation checks will no longer function, and the statement will need to manual escaping of all {sqlpp} special sequences and keywords).

NOTE: In addition the _N1qlQuery()_ is now deprecated and has been replaced with the _N1QL()_ call which has a different parameter format.

* _statement_
+
This is the identified {sqlpp} statement. This will be passed to {sqlpp} via SDK to run as a prepared statement. All referenced JS variables in the statement (using the $var notation) will be treated by {sqlpp} as named parameters.

* _params_
+
This can be either a JavaScript array (for positional parameters) or a JavaScript map. When the {sqlpp} statement utilizes positional parameters (i.e., $1, $2 ...), then params is expected to be a JavaScript array corresponding to the values to be bound to these positional parameters. When the {sqlpp} statement utilizes named parameters (i.e., $name), then params is expected to be a JavaScript map object providing the name-value pairs corresponding to the variables used by the {sqlpp} statement. Positional and named value parameters cannot be mixed.
+
Note, adding an optimal index to the `travel-sample`.`_default.`_default` keyspace for the below query can increase the performance by 57X.
+
_iterator using a positional params array_
+
[source,javascript]
----
    // Using `travel-sample`._default._default to demonstrate params.
    // a) Positional param 1 is field 'iata' from the input doc
    // b) Positional param 2 from an Eventing Function variable: max_dist
    // c) Will also prepare the statement for better performance
    
    if (doc.type !== "airline") return; // only process airline docs
    
    var max_dist = 120;
    var results = N1QL(
        "SELECT COUNT(*) AS cnt " +
        "FROM `travel-sample`._default._default " +
        "WHERE type = \"route\" " +
        "AND airline = $1 AND distance <= $2",
        [doc.iata,max_dist], 
        { 'isPrepared': true }
    );
----
+
_Example iterator using a named params object_
+
[source,javascript]
----
    // Using `travel-sample`._default._default to demonstrate named params.
    // a) Named param 1 '$mytype' is a hardcode
    // b) Named param 2 '$myairline' is field 'iata' from the input doc
    // c) Named param 3 '$mydistance' if from an Eventing Function variable max_dist
    // d) Set the consistency in the options to none
    
    if (doc.type !== "airline") return; // only process airline docs
    
    var max_dist = 120;
    var results = N1QL("SELECT COUNT(*) AS cnt " +
        "FROM `travel-sample`._default._default " +
        "WHERE type = $mytype " +
        "AND airline = $myairline AND distance <= $mydistance",
        { '$mytype': 'route', '$mydistance': max_dist, '$myairline': doc.iata },         
        { 'consistency': 'none' }
    );
----

* _options_
+
This is a JSON object having various query runtime options as keys. Currently, the following settings are recognized:

** _isPrepared_
+
This controls if the statement will be prepared. Normally, this defaults to _false_ but can be set on a per statement basis to _true_ for any {sqlpp} query that needs increased performance.

** _consistency_
+
This controls the consistency level for the statement. Normally, this defaults to the consistency level specified in the overall Eventing Function settings but can be set on a per statement basis. The valid values are "none" and "request".

* _return value (handle)_
+
The call returns a JavaScript Iterable object representing the result set of the query. The query is streamed in batches as the iteration proceeds. The returned handle can be iterated using any standard JavaScript mechanism including for...of loops.

** _close() Method on handle object (return value)_
+
This releases the resources held by the {sqlpp} query. If the query is still streaming results, the query is cancelled.

* _Exceptions Thrown_
+
The N1QL() function throws an exception if the underlying {sqlpp} query fails to parse or start executing. The returned Iterable handler throws an exception if the underlying {sqlpp} query fails after starting. The close() method on the iterable handle can throw an exception if underlying {sqlpp} query cancellation encounters an unexpected error.












[#crc64_call]
=== The crc64() Function Call

_crc64()_: This function calculates the CRC64 hash of an object using the ISO polynomial. The function
takes one parameter, the object to checksum, and this can be any JavaScript object that can be
encoded to JSON. The hash is returned as a string (because JavaScript numeric types offers only
53-bit precision). Note that the hash is sensitive to ordering of parameters in case of map
objects.

[source,javascript]
----
function OnUpdate(doc, meta) {
    var crc_str = crc64(doc);
    /// code here ...
}
----

The *crc64* function can be useful in cases like suppressing a duplicate mutation from the Sync Gateway (SG), when both the Sync Gateway & Eventing are leveraging the same bucket. Basically, Sync Gateway updates metadata of the document within the bucket, which in turn generates an event for Eventing to process. Eventing can't differentiate between events from Sync Gateway and other events (doc updates via SDK, {sqlpp}, and others).  A workaround to this double mutation issue is possible via the *crc64()* function.

[source,javascript]
----
function OnUpdate(doc, meta) {
    // Ignore documents created by Sync Gateway
    if(meta.id.startsWith("_sync") == true) return;

    // Ignore documents whose body has not changed since we last saw it
    var prev_crc = checksum_bucket[meta.id];
    var curr_crc = crc64(doc);
    if (prev_crc === curr_crc) return;
    checksum_bucket[meta.id] = curr_crc;

   // Business logic goes in here
}
----
Note that if multiple Eventing Functions share the same Sync Gateway crc64() checksum documents, real mutations will be suppressed and missed. In this use case make the checksum documents unique to each Eventing Function, i.e. checksum_bucket["evfunc1:" + meta.id], checksum_bucket["evfunc2:" + meta.id], etc.











[#timers_general]
== Timers

Timers are asynchronous compute, which offers Eventing Functions the ability to execute in reference to wall-clock events, refer to the detailed xref:eventing-timers.adoc[Timers] documentation. 

[#createtimer_call]
*The createTimer() Function Call*: _createTimer(callback, date, reference, context)_

To create a timer a callback or JavaScript function will be executed at or close to the desired date. The reference is an identifier for the timer scoped to an Eventing function and callback. The context must be serializable data that is available to the callback when the timer is fired. 
For more information see xref:eventing-timers.adoc#createtimer-function[createTimer function].

[#canceltimer_call]
*The cancelTimer() Function Call*: cancelTimer(callback, reference)

To cancel a timer you can either by invoking _createTimer()_ with the same reference of an existing timer or you can use the _cancelTimer() function.
For more information see xref:eventing-timers.adoc#canceltimer-function[cancelTimer function].








== cURL

[#curl_call]
*The curl() Function Call*: response_object = curl(method, binding, [request_object])

The curl() function provides a way of interacting with external entities via a REST endpoint from Eventing Functions using either HTTP or HTTPS.
For more information see xref:eventing-curl-spec.adoc[curl function].

[#handler-signatures]
== Handler Signatures

The Eventing Service calls the following entry points or JavaScript functions on events (mutations or fired timers).

* <<onupdate_handler,OnUpdate Handler>>
* <<ondelete_handler,OnDelete Handler>>
* <<timer_callback_handler,Timer Callback Handler>>

[#onupdate_handler]
=== OnUpdate Handler

The *OnUpdate* handler gets called when a document is created or modified, e.g. Insert/Update. The entry point OnUpdate(doc,meta) listens to mutations (the creation or modification of documents) in the associated source Bucket.

In this handler the following limitations exist, both limitations arise due to KV engine design choices and may be revisited in the future:

* If a document is modified several times in a short duration, the calls may be coalesced into a single event due to deduplication.
* It is not possible to distinguish between a Create and an Update operation.

A sample *OnUpdate* handler is displayed below:

[source,javascript]
----
function OnUpdate(doc, meta) {
  if (doc.type === 'order' && doc.value > 5000) {
    // ‘phonverify’ is a bucket alias or binding to a keyspace.
    phoneverify[meta.id] = doc.customer;
  }
}
----


[#ondelete_handler]
=== OnDelete Handler

The *OnDelete* handler gets called when a document is deleted or removed due to an expiry.

The entry point OnDelete(meta,options) listens to mutations (deletions or expirations) in the associated source Bucket.  You can determine if the document was deleted or expired via inspecting the optional argument "options" (a JavaScript map object with a boolean property named 'expired').

In this handler the following limitation exists. This limitation arises due to KV engine design choices and may be revisited in the future:

* it is not possible to get the value of the document that was just deleted or expired.

A sample *OnDelete* handler is displayed below:

[source,javascript]
----
function OnDelete(meta,options) {
    if (options.expired) {
        log("Document expired", meta.id);
    } else {
        log("Document deleted", meta.id);
    }
    var addr = meta.id;
    var res = SELECT id from mybucket.myscope.orders WHERE shipaddr = $addr;
    for (var id of res) {
        log("Address invalidated for pending order: " + id);
    }
}
----

Note that the pre-6.6.0 argument syntax, OnDelete(meta), that lacks "options" is still fully supported, but you will not be able to differentiate deletion from expiration.

[source,javascript]
----
function OnDelete(meta) {
    log("Document deleted or expired", meta.id);
}
----

[#timer_callback_handler]
=== Timer Callback Handler

Timer callbacks are user defined JavaScript functions passed as the callback argument to the built-in createTimer(callback, date, reference, context) function call.

These handlers (JavaScript functions) are the entry points for the event when a timer (created by the specific Eventing Function) matures and fires.

A sample Timer Callback Handler, the user defined JavaScript function *DocTimerCallback*, is displayed below:

[source,javascript]
----
// Timer Callback Handler (user defined entry point)
function DocTimerCallback(context) {
	log("Timer fired running callback 'DocTimerCallback' with context: " + context);
}

// Insert/Update Handler or entry point
function OnUpdate(doc, meta) {
	// filter out docs of no interest.
	if (meta.id != 'make_timer:1') return;
	// Create a Date value 60 seconds from now
	var oneMinuteFromNow = new Date(); // Get current time & add 60 sec. to it.
	oneMinuteFromNow.setSeconds(oneMinuteFromNow.getSeconds() + 60);
	// Create a doc to hold context to pass state to the callback function.
	var context = { docId: meta.id, random_text: "arbitrary text" };
	// Create a timer that will fire an event in the future.
	log("createTimer with callback 'DocTimerCallback'");
	createTimer(DocTimerCallback, oneMinuteFromNow, meta.id, context);
}
----

For more information see the <<timers_general,Timers>> section above and the detailed xref:eventing-timers.adoc[Timers] documentation.

== Reserved Words

Reserved words are words that cannot be used in a Eventing Function as a variable name, function name, or as a property in the Eventing Function's JavaScript code. The following table lists the reserved words that you must refrain from using as they are used by the transpiler to integrate with Couchbase's query language, {sqlpp} with Eventing.

|===
4+| {sqlpp} Keywords

| ALTER
| EXECUTE
| MERGE
| UPDATE

| BUILD
| EXPLAIN
| PREPARE
| UPSERT

| CREATE
| GRANT
| RENAME
|

| DELETE
| INFER
| REVOKE
|

| DROP
| INSERT
| SELECT
|
|===

*What Happens If You Use a Reserved Word?*

Let's say you try to create a new Eventing Function with JavaScript code using a reserved word for variable names, for function names, and as a property binding value. All three cases generate a deployment error.

Reserved words as a variable name:

[source,javascript]
----
function get_numip_first_3_octets(ip) {
    var grant = 0;
    if (ip) {
        var parts = ip.split('.');
    }
}
----

Reserved words as a function name:

[source,javascript]
----
function grant(ip) {
    var return_val = 0;
    if (ip) {
        var parts = ip.split('.');
    }
}
----

During the Function deployment step, when the system validates the Eventing Function's JavaScript code, it displays an error message such as the following:

....
Sample Error Message - Deployment failed: Syntax error (<line and column numbers>)
- grant is a reserved name in N1QLJs
....

Reserved words as a property bindings value:

image::reserved-words-7_0.png[,642]





















[#unsupported-lang-features]
== Unsupported Language Features

The following features are not supported by Eventing Functions:

* <<global_state,Global State>>
* <<asynchrony,Asynchrony>>
* <<browser_extensions,Browser and Other Extensions>>
* <<library_imports,Library Imports>>

[#global-state]
=== Global State

Eventing Functions do not support global variables.
This restriction makes sure that the logic of Eventing Functions remains agnostic of rebalance operations.

Instead of using global variables, you must save and retrieve all states from persistence providers like the Data Service.
You can use bindings to make all global states contained in Data Service buckets available to Eventing Functions.

[source,javascript]
----
var count = 0;                         // Not allowed - global variable.
function OnUpdate(doc, meta) {
  count++;
}
----

You can use Constant alias bindings in your Function's settings to access global constants within a Function's JavaScript.
For example, a Constant alias of `debug` with a value of `true` or `false` behaves in the same way as the statement `const debug = true`.

[#asynchrony]
=== Asynchrony

Eventing Functions do not support asynchronous flows.

Asynchrony creates a node-specific, long-running state that prevents persistence providers from capturing the entire state.
This limits Eventing Functions to execute short-running, straight-line code without sleep and wakeups.

You can use Timers to add limited asynchrony back into your Function. 
Timers are designed specifically to prevent a state from being node-specific.

[source,javascript]
----
function OnUpdate(doc, meta) {
  setTimeout(function(){}, 300);     // Not allowed - asynchronous flow.
}
----

[#browser_extensions]
=== Browser and Other Extensions

Eventing Functions do not support browser extensions, like window methods and DOM events.

You can use Timers instead of `setTimeout` and curl calls instead of `XMLHttpRequests`.

[source,javascript]
----
function OnUpdate(doc, meta) {
  var rpc = window.XMLHttpRequest();  // Not allowed - browser extension.
}
----

[#library_imports]
=== Library Imports

The Eventing Service does not support importing libraries into Eventing Functions.

