= Recursive WITH Clause
:description: Use the RECURSIVE keyword to enable recursive referencing in WITH common table expressions (CTEs).
:imagesdir: ../../assets/images
:page-topic-type: reference

[abstract]
{description}

[#purpose]
== Purpose

CTEs can be an expression or a temporary result set to be used as a data source for your query.
Their select definition is split on UNION/UNION ALL.

* The left arm of UNION/UNION ALL contains an anchor clause, which is non-recursive. 
The anchor clause produces an initial set of documents as an intermediate result set for the CTE keyspace.

* The right arm of UNION/UNION ALL contains the recursive clause.
The recursive clause produces a new set of documents.

The recursive clause is executed again, with the CTE keyspace now referring to the result produced by the initial recursive clause.
This process repeats until it results in an empty intermediate result set.
The intermediate result sets are appended to produce a final output.

[#syntax]
== Syntax

[source,ebnf]
----
include::partial$grammar/dql.ebnf[tag=recursive-with-clause]
----

image::n1ql-language-reference/recursive-with-clause.png["Syntax diagram", align=left]

----
include::partial$grammar/dql.ebnf[tag=recursive-with-clause-union]
----

image::n1ql-language-reference/recursive-with-clause-union.png["Syntax diagram UNION/UNION ALL", align=left]

[#arguments]
== Arguments

The following arguments are optional.

[source,ebnf]
----
include::partial$grammar/dql.ebnf[tag=recursive-with-clause-options]
----

image::n1ql-language-reference/recursive-with-clause-options.png["Argument diagram", align=left]

options:: Object that signals an early exit.
* `levels`: An exit after level `N`. 
This object assumes the Anchor is at level 0.
* `documents`: An exit after accumulating `N` documents. 

[source,ebnf]
----
include::partial$grammar/dql.ebnf[tag=recursive-with-clause-cycle]
----

image::n1ql-language-reference/recursive-with-clause-cycle.png["Argument diagram", align=left]

cycle:: `CYCLE <fieldnames_list> RESTRICT`. 
List of field names in which you want to perform cycle detection.

[#limitations]
== Limitations

* The recursive reference is only allowed once in the FROM clause.
It's not allowed anywhere else.

* ORDER BY, LIMIT, and OFFSET clauses are not allowed in the SELECT statement in the subquery used to define the anchor and the recursive clause.

* The DISTINCT quantifier is not allowed in anchor and recursive clauses.

* GROUP BY, WINDOW, and AGGREGATE functions are not allowed in recursive clauses.

* OUTER JOINS are not allowed in recursive clauses because they can lead to potential infinite recursion.

* Recursive clauses do not support NEST and UNNEST clauses.

* If there is no UNION/UNION ALL separation for the recursive CTE, the query defaults to a normal CTE.

* A syntax error is returned when optional subclauses are used without the RECURSIVE keyword.

* In general, recursion is also limited by:
** The logic in the recursive statement.
** The stop in the options argument.
** Breaching the request timeout, if confifured.
** Breaching the request memory quota, if configured.
** Exceeding the implicit document limit (10000) when a memory quota is not in use and when no explicit document limit has been set in the options.
** Exceeding the implicit level limit (1000) when the level option is not in use.

[#examples_section]
== Examples

The following examples follow linear recursion.
Only one recursive reference is allowed in the FROM clause.
Self-joins or set-ops are not allowed in the recursive reference.

.Example of simple recursive referencing
====
[source,sqlpp]
----
WITH RECURSIVE cte AS (
    SELECT 1 AS r 
        UNION 
    SELECT cte.r+1 AS r 
    FROM cte 
    WHERE cte.r<4 
) 
SELECT cte.r FROM cte;
----

.Results
[source,json]
----
[
  {
    "r": 1
  },
  {
    "r": 2
  },
  {
    "r": 3
  },
  {
    "r": 4
  }
]
----
====

.Example combining recursive and non-recursive CTEs with the WITH clause
====
[source,sqlpp]
----
WITH RECURSIVE cte AS (SELECT 1 r) ,
    rcte AS ( 
        SELECT cte.r FROM cte 
            UNION 
        SELECT rcte.r+2 r FROM rcte WHERE rcte.r<7
    )
SELECT * FROM rcte;
----

.Results
[source,json]
----
[
  {
    "rcte": {
      "r": 1
    }
  },
  {
    "rcte": {
      "r": 3
    }
  },
  {
    "rcte": {
      "r": 5
    }
  },
  {
    "rcte": {
      "r": 7
    }
  }
]
----
====

.Example finding all possible routes leaving from the TLV airport and going to 2 other airports
====
[source,sqlpp]
----
WITH RECURSIVE recroute AS (
    SELECT sourceairport, destinationairport, 0 as depth,
    [ sourceairport, destinationairport ] as route
    FROM `travel-sample`.inventory.route 
    WHERE sourceairport="TLV"
        UNION
    SELECT r.sourceairport, r.destinationairport, 
    ARRAY_APPEND ( recroute.route, r.destinationairport ) as route,
        recroute.depth+1 as depth
    FROM `travel-sample`.inventory.route r JOIN recroute ON 
        recroute.destinationairport = r.sourceairport
    WHERE r.sourceairport!="TLV" and recroute.depth<2 
)
SELECT * FROM recroute LIMIT 10;
----

.Results
[source,json]
----
[
  {
    "recroute": {
      "depth": 0,
      "destinationairport": "BSL",
      "route": [
        "TLV",
        "BSL"
      ],
      "sourceairport": "TLV"
    }
  },
  {
    "recroute": {
      "depth": 0,
      "destinationairport": "CDG",
      "route": [
        "TLV",
        "CDG"
      ],
      "sourceairport": "TLV"
    }
  },
  {
    "recroute": {
      "depth": 0,
      "destinationairport": "EWR",
      "route": [
        "TLV",
        "EWR"
      ],
      "sourceairport": "TLV"
    }
  },
  {
    "recroute": {
      "depth": 0,
      "destinationairport": "FCO",
      "route": [
        "TLV",
        "FCO"
      ],
      "sourceairport": "TLV"
    }
  },
  {
    "recroute": {
      "depth": 0,
      "destinationairport": "GVA",
      "route": [
        "TLV",
        "GVA"
      ],
      "sourceairport": "TLV"
    }
  },
  {
    "recroute": {
      "depth": 0,
      "destinationairport": "JFK",
      "route": [
        "TLV",
        "JFK"
      ],
      "sourceairport": "TLV"
    }
  },
  {
    "recroute": {
      "depth": 0,
      "destinationairport": "LAX",
      "route": [
        "TLV",
        "LAX"
      ],
      "sourceairport": "TLV"
    }
  },
  {
    "recroute": {
      "depth": 0,
      "destinationairport": "LGW",
      "route": [
        "TLV",
        "LGW"
      ],
      "sourceairport": "TLV"
    }
  },
  {
    "recroute": {
      "depth": 0,
      "destinationairport": "LHR",
      "route": [
        "TLV",
        "LHR"
      ],
      "sourceairport": "TLV"
    }
  },
  {
    "recroute": {
      "depth": 0,
      "destinationairport": "LTN",
      "route": [
        "TLV",
        "LTN"
      ],
      "sourceairport": "TLV"
    }
  }
]
----
====