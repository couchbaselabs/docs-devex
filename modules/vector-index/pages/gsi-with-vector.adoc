= Use GSI with a Vector Column
:page-topic-type: guide
:page-ui-name: {ui-name}
:page-product-name: {product-name}
:description: You can extend a Couchbase {product-name}'s Global Secondary Index (GSI) with a single vector column to enable queries to find semantically-related content.

{description}

The added vector column lets your application perform a hybrid query using both the index's scalar. array, and object index entries plus a vector value. 
See xref:learn:services-and-indexes/indexes/indexes.adoc[] for an overview of GSI and other indexes.

== How the GSI's Vector Column Works 

You can add a single vector column to a GSI to enable semantic and similarity searches within your {sqlpp} queries.
When creating the index, you use a `VECTOR` key attribute to designate the attribute that contains the embedded vectors.
In the process of creating the index, the Index Service quantizes the data in the attribute to make it easier to scan and process. 
For more information about quantization, see xref:use-vector-indexes.adoc#quantize[Reducing Vector Complexity].

When your query contains a embedded vector, the Query Service uses any non-vector predicates in the query to filter index entries.
Then it performs an index scan on the remaining index entries, using the similarity function you specify in the query to locate similar vectors. 
This behavior reduces the number of vector similarity comparisons the Query Service must do to find similar vectors.


== Prerequisites

* You must have the Index Service enabled on a node in your database. 
For more information about how to deploy a new node and Services on your database, see xref:manage:manage-nodes/node-management-overview.adoc[].

* You must have a bucket with scopes and collections in your database. 
For more information about how to create a bucket, see xref:manage:manage-buckets/create-bucket.adoc[].

* Your account must have the xref:learn:security:roles.adoc#query-manage-index[Query Manage Index] role to be able to create an index.

* You have documents in a collection that contain one or more vector embeddings.
You can add a single vector to a GSI index.
If your documents contain multiple embedded vectors, you can create multiple indexes---one for each vector attribute.
+
Embeddings can be an array of floats or a base64 encoded string.
Couchbase {product-name} does not embed vectors itself. 
You must use an external embedding model to embed vectors into your data and add them to your documents.
+
[TIP]
--
include::vector-search:partial$download-sample-partial.adoc[]
--

* You must know the number of dimensions the vector contains. 
The embedding model you use to embed the vectors determines this value for you.  
For example,  OpenAI API's `text-embedding-ada-002` embedding model that was used for the sample data creates vectors that have 1536 dimensions.

You also have several options to choose before you create a GSI that has a vector column:


* The type of quantization you want to use when storing the vector in you your index.
GSI vector columns support two types of quantization: Scalar Quantization (SQ) and Product Quantization (PQ). 
See xref:vector-index:use-vector-indexes.adoc#quantize[Reducing Vector Size] for more information about quantization.
+ 
In addition to the quantization type, you can also supply a value that affects the quantization:
+
** For SQ, the value sets the data type and number of bits that represent a dimension. For example, `SQ8` uses 8 bits to represent a dimension. `SQfp16` uses a 16-bit floating point value to represent a dimension.
** For PQ, the value sets the number of subquantizers and the number of bits each quantizers uses. For example `PQ8x8` uses 8 subquantizer each of which uses 8 bits. `PQ32x8` uses thirty two quantizers with 8 bits per quantizer. 
* Optionally, choose the number of centroids to use if the quantization uses centroids.

* The proximity function to use when generating the index. 
For the best results, use the same proximity function used to embed the 

== Create a GSI with a Vector Column

Creating a GSI with a vector column is similar to creating a non-vector GSI index.
In the `CREATE INDEX` statement to create the GSI, add the `VECTOR` lead key attribute after the  vector's to declare that the attribute contains an embedded vector.

You must also use the `WITH` clause to specify some additional information for the vector column:

* `dimension` in an integer value that sets the number of dimensions in the vector.
* `similarity` is a string that sets the distance function to use when comparing vectors during index creation.
For the highest accuracy, use the distance function you plan to use when querying or searching vector data.
* `description` is a string that sets the number of centroids and the quantization to use when creating the index. 
The format for this string is:
+
[source,sqlpp]
----
'IVF<number_of_centroids>,[PQ|SQ]<quantization_setting>'
----

// Note: I originally thought that the similarity function had to match the function used to embed the vectors, but
// embedding doesn't require a distance function? But there was a reference to keeping the function here and in the queries
// the same, so will mention that later.

[#examples]
=== Examples

The following examples show you how to create two Global Secondary Indexes with a vector column using the sample data.
They both use the data from the `color_data_2vectors.zip` file mentioned previously. 
The data in `rgb.json` file looks like this:

[source,json]
----
[
  {
    "id": "#FFEFD5",
    "color": "papaya whip",
    "brightness": 240.82,
    "colorvect_l2": [
      255,
      239,
      213
    ],
    "wheel_pos": "other",
    "verbs": [
      "soften",
      "mellow",
      "lighten"
    ],
    "description": "Papaya whip is a soft and mellow color that can be described as a light shade of 
    peach or coral. It has a calming and soothing effect, similar to the tropical fruit it is named 
    after. This color is perfect for creating a warm and inviting atmosphere, and it pairs well with 
    other pastel shades or neutral tones. Papaya whip is a versatile color that can be used in both 
    fashion and interior design, adding a touch of elegance and sophistication to any space.",
    "embedding_model": "text-embedding-ada-002-v2",
    "embedding_vector_dot": [
      -0.014644118957221508,
      0.017003899440169334,
      -0.013450744561851025,
      0.0021356006618589163,
      0.006283756345510483,
      0.01162360142916441,
    // . . . 
    ]
 },
 // . . . 
] 
----

==== Index the RGB Values

The `rgb.json` file's `colorvect_l2` attribute defines an array containing the RGB values for the entry's color. 
While this technically is not an embedded vector, you can still create a vector index column for this array. 
The following example creates a GSI for this attribute as an embedded vector as well as the color's name and brightness.

[source,sqlpp]
----
include::vector-index:example$gsi-vector-idx-examples.sqlpp[tag=create-rgb-idx]
----

In this example:

* The number of dimensions is 3, because there are three values in the array containing the RGB value.
* The similarity function is `L2`. 
This is a slower, but more accurate function that other options.
* The description sets the index column to use SQ quantization, reducing dimension values to an 8-bit value.

The result of running example is:

[source,json]
----
[
  {
    "id": "f572fa0b1c7358ee",
    "name": "color_vectors_idx",
    "state": "online"
  }
]
----

==== Create a GSI Using the Embedded Vectors

The `embedding_vector_dot` attribute contains the embedded vectors for the text in the `description` attribute.
The data sample shown in <<#examples>> truncated this attribute to several values.
The embedded vector contains 1536 dimensions.

The following example creates a GSI that indexes the embedded vectors in the `embedding_vector_dot` as well as indexing the scalar `color` that contains the color's name and `brightness.`

[source,sqlpp]
----
include::vector-index:example$gsi-vector-idx-examples.sqlpp[tag=create-vectors-idx]
----

If successful, Couchbase {product-name} responds with:

[source, json]
----
[
  {
    "id": "c965205718c3e4c2",
    "name": "color_desc_idx",
    "state": "online"
  }
]
----

== Query with a GSI Vector Column

You query embedded vector attributes that you have indexed in a GSI to find similar vectors and therefore similar semantic content.
To find the most similar vectors, you use a `GROUP BY` clause in your query to return the most relevant vectors first. 
In this clause, you call one of two functions that actually performs the vector comparisons: `APPROX_VECTOR_DISTANCE` or `VECTOR_DISTANCE`.
The first of these functions is faster, but less precise.
The second is more precise, but slower.
Which you choose depends on your use case.

=== Query RGB Values

Querying the RGB values in `rgb.colorvect_l2` requires a vector with only three values.
You can easily specify the vector by hand.
The following example finds colors that are similar to grey, which has an RGB value of 128, 128, 128:

[source, sqlpp]
----
include::vector-index:example$gsi-vector-idx-examples.sqlpp[tag=query-rgb-idx]
----

The query uses the `APPROX_VECTOR_DISTANCE` function to sort the results. 
You pass it the vector column to search, the vector to search for (in this case, the array `128, 128, 128`) and the distance function.
For the best accuracy, use the same distance function you specified when creating the GSI (in this case, `L2`).
The `LIMIT` clause is pushed down into the index scan, so once it finds the 5 entries that satify the query, it exits.

The top result is the entry for grey. The other results are all shades of grey:

[source,json]
----
[{
        "color": "grey",
        "colorvect_l2": [
            128,
            128,
            128
        ],
        "brightness": 128
    },
    {
        "color": "slate gray",
        "colorvect_l2": [
            112,
            128,
            144
        ],
        "brightness": 125.04
    },
    {
        "color": "light slate gray",
        "colorvect_l2": [
            119,
            136,
            153
        ],
        "brightness": 132.855
    },
    {
        "color": "light gray",
        "colorvect_l2": [
            144,
            144,
            144
        ],
        "brightness": 144
    },
    {
        "color": "dim gray",
        "colorvect_l2": [
            105,
            105,
            105
        ],
        "brightness": 105
    }
]
----

You can also add other predicates to help reduce the workload of searching for similar vectors by excluding vectors.
The following example searches for colors similar to grey, which has an RGB value of 128, 128, 128 and have a brightness greater than 128:

[source, sqlpp]
----
include::vector-index:example$gsi-vector-idx-examples.sqlpp[tag=query-rgb-idx-w-predicate[]
----

The result of running this query are:

[source, json]
----
[{
        "color": "light slate gray",
        "colorvect_l2": [
            119,
            136,
            153
        ],
        "brightness": 132.855
    },
    {
        "color": "light gray",
        "colorvect_l2": [
            144,
            144,
            144
        ],
        "brightness": 144
    },
    {
        "color": "cadet blue",
        "colorvect_l2": [
            95,
            158,
            160
        ],
        "brightness": 139.391
    },
    {
        "color": "rosy brown",
        "colorvect_l2": [
            188,
            143,
            143
        ],
        "brightness": 156.455
    },
    {
        "color": "dark sea green",
        "colorvect_l2": [
            143,
            188,
            143
        ],
        "brightness": 169.415
    }
]
----

===  Query the Embedded Vectors

To query the `color_desc_idx` GSI containing the embedded vector for the description attribute, you must supply a vector.
In a production environment, your application will call the same embedding model it called to generate the embedded vectors in your documents to generate a vector for the query value.

For this example, you can use embedded vectors in the `rgb_questions.json` file that's in the `color_data_2vectors.zip` file.
This file contains a `question` attribute containing a search prompt for a particular color. 
The `couchbase_search_query.knn.vector` attribute contains the embedded vector for the `question` attribute:

[source,json]
----
[
  {
    "id": "#FFEFD5",
    "question": "What is the name of the color that is reminiscent of a tropical fruit and has a calming
     effect, often used in fashion and interior design?",
    "wanted_similar_color_from_search": "papaya whip",
    "embedding_model": "text-embedding-ada-002-v2",
    "couchbase_search_query": {
      "fields": [
        "*"
      ],
      "knn": [
        {
          "field": "embedding_vector_dot",
          "k": 3,
          "vector": [
            0.005115953739732504,
            0.004331615287810564,
            0.014279481954872608,
            // ....
          ]
        }
      ],
      "query": {
        "match_none": {}
      },
      "sort": [
        "-_score"
      ]
    }
  },
  // ...
]
----


This example uses the more accurate `VECTOR_DISTANCE` function to order the results of querying the  `embedding_vector_dot` column. 
It appears here with most of the 1536 vectors omitted:

[source,sqlpp]
----
include::vector-index:example$gsi-vector-idx-examples.sqlpp[tag=query-vectors-idx-truncated]
----

You can expand the following dropdown to see and copy the entire query with all the vectors:

.Show full example
[%collapsible]
====
[source,sqlpp]
----
include::vector-index:example$gsi-vector-idx-examples.sqlpp[tag=query-vectors-idx-whole]
----
====

Another option is to import the `rgb_questions.json` file into another collection in the `vector-sample` bucket's `colors` scope named `rgb-questions`.
Then you can use a subquery to get the vectors for the question and use it in your query of the `rgb` collection's `embedding_vector_dot` attribute:

[source,sqlpp]
----
include::vector-index:example$gsi-vector-idx-examples.sqlpp[tag=query-vectors-idx-subquery]
----

In either case, the results of the query are the same:

[source,json]
----
[
  {
    "color": "cantalope",
    "description": "The color cantaloupe is a soft and soothing shade that evokes feelings of calmness 
    and relaxation. It is a refreshing hue that brings to mind the juicy and sweet fruit it is named 
    after. This delicate color is a pale orange with hints of pink, giving it a subtle and gentle 
    appearance. It is a perfect color for creating a peaceful and tranquil atmosphere."
  },
  {
    "color": "papaya whip",
    "description": "Papaya whip is a soft and mellow color that can be described as a light shade of 
    peach or coral. It has a calming and soothing effect, similar to the tropical fruit it is named 
    after. This color is perfect for creating a warm and inviting atmosphere, and it pairs well with 
    other pastel shades or neutral tones. Papaya whip is a versatile color that can be used in both 
    fashion and interior design, adding a touch of elegance and sophistication to any space."
  },
  {
    "color": "apricot",
    "description": "Apricot is a warm and inviting color, reminiscent of the soft glow of a sunset. It 
    has the ability to soften the harshness of other colors and enliven any space it is used in. It is a 
    delicate and soothing hue, perfect for creating a cozy and welcoming atmosphere."
  }
]
----

The second result, the color "papaya whip," matches the `rgb_questions`'s `wanted_similar_color_from_search` attribute. 